/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package de.uni_leipzig.simba.execution.rewriter;

import de.uni_leipzig.simba.controller.Parser;
import de.uni_leipzig.simba.specification.LinkSpec;
import de.uni_leipzig.simba.specification.Operator;
import java.util.ArrayList;
import java.util.List;
import org.apache.log4j.Logger;

/**
 *
 * @author ngonga
 */
public class AlgebraicRewriter implements Rewriter {

    /**
     * Rewrites a Link Specification and returns an equivalent yet probably more
     * time-efficient link spec
     *
     * @param spec Input link specification
     * @return Rewritten spec
     */
    static Logger logger = Logger.getLogger("LIMES");

    public LinkSpec rewrite(LinkSpec spec) {
        //rewrite only non-atomic specs
//        if(spec.size() <= 1) return spec;
        int oldSize;
        int newSize = spec.size();
        int counter = 0;
        LinkSpec result = spec;
        try {
            do {
                counter++;
                //System.out.println(counter + " -> " + spec);
                oldSize = newSize;
                spec = updateThresholds(spec);
                spec = computeAllDependencies(spec);
                spec = collapseSpec(spec);
                spec = removeUnaryOperators(spec);
                newSize = spec.size();
                result = spec;
            } while (newSize < oldSize);
        } catch (Exception e) {
            logger.error(e.getMessage());
            e.printStackTrace();
        }
        return result;
    }

    /**
     * Updates the thresholds within the input spec
     *
     * @param spec
     * @return Return spec with updated weights
     */
    public LinkSpec updateThresholds(LinkSpec spec) {
        //should not happen
        if (spec.isEmpty()) {
            return spec;
        }
        //does not work for atomic specs
        if (!spec.isAtomic()) {
            // only works for null filters
            if (spec.getFilterExpression() == null) {
                double min = 1f;
                //get minimum over all children
                for (LinkSpec child : spec.children) {
                    if (child.threshold < min) {
                        min = child.threshold;
                    }
                }
                // if spec threshold smaller than miminum then set to 0
                if (spec.threshold <= min) {
                    spec.threshold = 0;
                }
            }
            //if spec has children then run update for children as well
            for (LinkSpec child : spec.children) {
                child = updateThresholds(child);
            }
        }
        return spec;
    }

    /**
     * Removes unary operators from a spec
     *
     * @param spec Input
     * @return Cleaned up spec
     */
    public LinkSpec removeUnaryOperators(LinkSpec spec) {
        if (!spec.isAtomic() && !spec.isEmpty()) {
            if (spec.getFilterExpression() == null && spec.children.size() == 1) {
                //don't forget to update the threshold while lifting the branch 
                double theta = Math.max(spec.threshold, spec.children.get(0).threshold);
                System.out.print("Old spec = " + spec + "\t");

                spec = spec.children.get(0);
                spec.threshold = theta;
                System.out.println("New spec = " + spec + "\t");
            }
            if (!spec.isAtomic()) {
                List<LinkSpec> newChildren = new ArrayList<LinkSpec>();
                for (LinkSpec child : spec.children) {
                    newChildren.add(removeUnaryOperators(child));
                }
                spec.children = newChildren;
            }
        }
        return spec;
    }

    /**
     * Checks whether source depends on target, i.e., whether the mapping
     * generated by source is a subset of the mapping generated by target.
     * Returns 0 if no dependency is found, 1 if target is included in source,
     * -1 if source is included in target and +2 if they are equivalent
     *
     * @param source Source link spec
     * @param target Target link spec
     * @return -1, 0, +1 or +2
     */
    public LinkSpec computeAtomicDependency(LinkSpec source, LinkSpec target) {
        //only works for atomic properties
        if (!source.isAtomic() || !target.isAtomic()) {
            return source;
        }
        //compute the source and target properties used. Only works if the properties
        //used by the spec are the same
        if (getProperties(source).equals(getProperties(target))) {
            String measure1 = getMeasure(source);
            String measure2 = getMeasure(target);
            if (measure1.equals(measure2)) {
                if (source.threshold <= target.threshold) {
                    source.addDependency(target);
                } else {

                    double t1 = source.threshold;
                    double t2 = target.threshold;
                    if (measure1.equals("trigrams")) {
                        //works for jaro vs. jaro-winkler
                        //
                    } else if (measure2.equals("overlap")) {
                        if (measure2.equals("jaccard") && t2 <= 2 * t1 / (1 + t1)) {
                            source.addDependency(target);
                        }
                    }
                }
            }
        }
        return source; //nothing found
    }

    /**
     * Returns the properties that are used for the comparison Only works for
     * atomatic specs
     *
     * @param spec Input spec
     * @return List of properties used in the spec
     */
    public List<String> getProperties(LinkSpec spec) {
        List<String> result = new ArrayList<String>();
        if (spec.isAtomic()) {
            Parser p = new Parser(spec.getFilterExpression(), spec.threshold);
            result.add(p.getTerm1());
            result.add(p.getTerm2());
        }
        return result;
    }

    /**
     * Returns the measure used in the spec
     *
     * @param spec Specification
     * @return Measure used in the spec, null if the spec is not atomic
     */
    public String getMeasure(LinkSpec spec) {
        if (spec.isAtomic()) {
            return spec.getFilterExpression().substring(0, spec.getFilterExpression().indexOf("("));
        } else {
            return null;
        }
    }

    /**
     * Updates all dependencies within a spec
     *
     * @param spec Input spec
     * @return Spec with all dependencies updated
     */
    public LinkSpec computeAllDependencies(LinkSpec spec) {
        spec = computeAtomicDependencies(spec);
        spec = computeNonAtomicDependencies(spec);
        return spec;
    }

    /**
     * Updates the non-atomic dependencies of a link spec
     *
     * @param spec
     * @return
     */
    public LinkSpec computeNonAtomicDependencies(LinkSpec spec) {
        if (!spec.isAtomic()) {
            List<LinkSpec> newDependencies = null;
            List<LinkSpec> newChildren = new ArrayList<LinkSpec>();
            //first update dependencies of children
            for (LinkSpec child : spec.children) {
                newChildren.add(computeNonAtomicDependencies(child));
            }
            spec.children = newChildren;
            //then update spec itself
            //if operator = AND, then dependency is intersection of all dependencies
            if (spec.operator == Operator.AND && spec.children.get(0).hasDependencies()) {
                newDependencies = spec.children.get(0).dependencies;
                for (int i = 1; i < spec.children.size(); i++) {
                    if (!spec.children.get(i).hasDependencies()) {
                        break;
                    } else {
                        newDependencies.retainAll(spec.children.get(i).dependencies);
                    }
                }
            }
            //if operator = OR, then merge all
            if (spec.operator == Operator.OR) {
                newDependencies = new ArrayList<LinkSpec>();
                for (LinkSpec child : spec.children) {
                    if (child.hasDependencies()) {
                        newDependencies.addAll(child.dependencies);
                    }
                }
            }
            spec.dependencies = null;

            if (newDependencies != null) {
                for (LinkSpec d : newDependencies) {
                    if (d.threshold > spec.threshold || spec.threshold == 0) {
                        spec.addDependency(d);
                    }
                }
            }
        }
        return spec;
    }

    /**
     * Computes all dependencies within a link specification
     *
     * @param spec Input spec
     * @return spec with all dependencies computed
     */
    public LinkSpec computeAtomicDependencies(LinkSpec spec) {
        List<LinkSpec> leaves = spec.getAllLeaves();
        //compute the dependency between leaves
        for (int i = 0; i < leaves.size(); i++) {
            //reset dependencies
            leaves.get(i).dependencies = new ArrayList<LinkSpec>();
            for (int j = 0; j < leaves.size(); j++) {
                if (i != j) {
                    leaves.set(i, computeAtomicDependency(leaves.get(i), leaves.get(j)));
                }
            }
        }
        return spec;
    }

    /**
     * Collapses a spec by making use of the dependencies within the spec
     *
     * @param spec Input spec
     * @return Collapsed spec, i.e., spec where dependencies have been removed
     */
    public LinkSpec collapseSpec(LinkSpec spec) {
        if (spec.isAtomic() || spec.isEmpty()) {
            return spec;
        }
        //first collapse children which depend on each other 
        if (spec.operator == Operator.AND) {
            List<LinkSpec> newChildren = new ArrayList<LinkSpec>();
            newChildren.addAll(spec.children);
            //child is a superset of its dependencies, thus
            //if one of its dependency is a child of the current node, then
            //no need to compute child
            for (LinkSpec child : spec.children) {
                if (child.hasDependencies()) {
                    for (LinkSpec dependency : child.dependencies) {
                        if (newChildren.contains(dependency)) {
                            //ensures that at least one child is kept, in case of cyclic dependencies
                            //quick fix. Might not work
                            if (newChildren.size() > 1) {
                                newChildren.remove(child);
                            }
                        }
                    }
                }
            }
            spec.children = newChildren;
        } else if (spec.operator == Operator.OR) {
            List<LinkSpec> newChildren = new ArrayList<LinkSpec>();
            newChildren.addAll(spec.children);
            for (LinkSpec child : spec.children) {
                if (child.hasDependencies()) {
                    for (LinkSpec dependency : child.dependencies) {
                        // all entries of dependency contained in child, so 
                        // no need to compute it
                        if (newChildren.contains(dependency)) {
                            //ensures that at least one child is kept, in case of cyclic dependencies
                            //quick fix. Might not work
                            if (newChildren.size() > 1) {
                                newChildren.remove(dependency);
                            }
                        }
                    }
                }
            }
            spec.children = newChildren;
        }
        List<LinkSpec> newChildren = new ArrayList<LinkSpec>();
        //now collapse remaining children
        for (LinkSpec child : spec.children) {
            newChildren.add(collapseSpec(child));
        }
        spec.children = newChildren;
        return spec;
    }

    /**
     * Computes dependencies between nodes of a spec
     *
     * @param args
     */
    public static void main(String args[]) {
        //still need to write the overall rewriter method
        rewriteTest();
    }

    /**
     * Test for update threshold
     *
     */
    public static void updateThresholdsTest() {
        AlgebraicRewriter ar = new AlgebraicRewriter();
        LinkSpec spec = new LinkSpec();
        LinkSpec spec2 = new LinkSpec();
        spec.readSpec("AND(trigrams(x.p, y.p)|0.6, AND(euclidean(x.q, y.q)|0.7, linear(x.s, y.s)|0.7)|0.6)", 0.5);
        spec2.readSpec("AND(euclidean(x.q, y.q)|0.7, linear(x.s, y.s)|0.7)", 0.7);
        System.out.println(spec + "\n" + spec2);
        System.out.println(ar.updateThresholds(spec));
        System.out.println(ar.updateThresholds(spec2));
        //spec = ar.updateThresholds(spec.clone());
        System.out.println(spec);
        System.out.println(spec2);
    }

    /**
     * Test for rewriting
     *
     */
    public static void rewriteTest() {
        LinkSpec spec = new LinkSpec();
        spec.readSpec("AND(XOR(levenshtein(x.authors,y.authors)|0.9135,XOR(cosine(x.venue,y.venue)|0.5183,overlap(x.title,y.title)|0.5183)|0.4506)|0.4506,AND(XOR(overlap(x.authors,y.authors)|0.4506,OR(levenshtein(x.authors,y.authors)|0.4506,euclidean(x.year,y.year)|0.9304)|0.5558)|0.0073,overlap(x.title,y.title)|0.7019)|0.7019)", 0.5);
//        spec.readSpec("OR(trigrams(x.q, y.q)|0.75, AND(jaccard(x.q, y.q)|0.7, jaccard(x.q, y.q)|0.5)|0.8)", 0.5);
        AlgebraicRewriter ar = new AlgebraicRewriter();
        System.out.println(spec);
        spec = ar.rewrite(spec);
        System.out.println(spec);
    }

    /**
     * Test for dependency computation
     *
     */
    public static void dependencyTest() {
        AlgebraicRewriter ar = new AlgebraicRewriter();
        LinkSpec spec = new LinkSpec();
        spec.readSpec("jaccard(x.q, y.q)", 0.5);
        LinkSpec spec2 = new LinkSpec();
        spec2.readSpec("jaccard(x.q, y.o)", 0.7);
        //System.out.println(ar.computeAtomicDependency(spec, spec2));

        spec.readSpec("OR(jaccard(x.q, y.q)|0.75, AND(jaccard(x.q, y.q)|0.7, jaccard(x.q, y.q)|0.5)|0.8)", 0.5);
        spec = ar.computeAllDependencies(spec);
        System.out.println(spec);
        spec = ar.collapseSpec(spec);
        System.out.println(spec);
        spec = ar.removeUnaryOperators(spec);
        System.out.println(spec);
        spec = ar.updateThresholds(spec);
        spec = ar.removeUnaryOperators(spec);
        System.out.println(spec);
    }

    /**
     * Test for unary removal threshold
     *
     */
    public static void unaryTest() {
        AlgebraicRewriter ar = new AlgebraicRewriter();
        LinkSpec spec = new LinkSpec();
        LinkSpec spec2 = new LinkSpec();
        LinkSpec spec3 = new LinkSpec();

        spec.readSpec("trigrams(x.p, y.p)", 0.7);
        spec2.readSpec("euclidean(x.q, y.q)", 0.3);
        spec3.threshold = 0.5;
        spec3.operator = Operator.AND;
        spec.addChild(spec3);
        spec3.addChild(spec2);
        System.out.println(spec);
        spec = ar.removeUnaryOperators(spec);
        System.out.println(spec);
    }
}
