/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package de.uni_leipzig.simba.selfconfig;

import de.uni_leipzig.simba.cache.Cache;
import de.uni_leipzig.simba.cache.MemoryCache;
import de.uni_leipzig.simba.data.Mapping;
import de.uni_leipzig.simba.execution.ExecutionEngine;
import de.uni_leipzig.simba.execution.Instruction;
import de.uni_leipzig.simba.execution.Instruction.Command;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 *
 * @author ngonga
 */
public class BooleanSelfConfigurator extends LinearSelfConfigurator {
   public static String MEASURE = "reference";

    /** Gets the best target for each source and returns it
     * 
     * @param m
     * @return 
     */

    public Mapping getBestOneToOneMapping(Mapping m) {
        Mapping result = new Mapping();
        for (String s : m.map.keySet()) {
            double maxSim = 0;
            Set<String> target = new HashSet<String>();;
            for (String t : m.map.get(s).keySet()) {
                if (m.getSimilarity(s, t) == maxSim) {
                    target.add(t);
                }
                if (m.getSimilarity(s, t) > maxSim) {
                    maxSim = m.getSimilarity(s, t);
                    target = new HashSet<String>();
                    target.add(t);
                }
            }
            for (String t : target) {
                result.add(s, t, maxSim);
            }
        }
        return result;
    }

    /** Constructor
     * 
     * @param source Source cache
     * @param target Target cache
     * @param beta Beta value for computing F_beta
     * @param minCoverage Minimal coverage for a property to be considered for linking
     * 
     */
    public BooleanSelfConfigurator(Cache source, Cache target, double minCoverage, double beta) {
        this.source = source;
        this.target = target;
        this.beta = beta;
        sourcePropertiesCoverageMap = getPropertyStats(source, minCoverage);
        targetPropertiesCoverageMap = getPropertyStats(target, minCoverage);
        measures = new HashMap<String, String>();
        measures.put("euclidean", "numeric");
        measures.put("levenshtein", "string");
        measures.put("jaccard", "string");
        measures.put("trigrams", "string");
        setMeasure(MEASURE);
    }

    /** Aims to improve upon a particular classifier by checking whether adding a delta
     * to its similarity worsens the total classifer
     * @param mappings Current classifiers and their mappings
     * @param toImprove Classifier that is to be updated
     * @return Improved classifiers and their mapping
     */
    public ComplexClassifier computeNext(ComplexClassifier classifier, int index) {
        ComplexClassifier cc = classifier.clone();
        ComplexClassifier result = new ComplexClassifier(null, 0.0);
        if (cc.classifiers.get(index).threshold > learningRate) { // 
            cc.classifiers.get(index).threshold = cc.classifiers.get(index).threshold - learningRate;
            Mapping m = getMapping(cc.classifiers);
            result.classifiers = cc.classifiers;
            result.fMeasure = computeQuality(m);
//            result.fMeasure = _measure.getPseudoFMeasure(source.getAllUris(), target.getAllUris(), m, beta);
            return result;
        } else {
            if (cc.classifiers.size() > index + 1) {
                List<SimpleClassifier> cp = new ArrayList<SimpleClassifier>();
                for (int i = 0; i < cc.classifiers.size(); i++) {
                    if (i != index) {
                        cp.add(cc.classifiers.get(i));
                    }
                }
                Mapping m = getMapping(cp);
                result.classifiers = cp;
                result.fMeasure = computeQuality(m);
//                result.fMeasure = _measure.getPseudoFMeasure(source.getAllUris(), target.getAllUris(), m, beta);
                return result;
            } else {
                return result;
            }
        }
    }

    /** Runs classifiers and retrieves the correspoding mappings
     * 
     * @param classifiers List of classifiers
     * @return Mapping generated by the list of classifiers
     */
    @Override
    public Mapping getMapping(List<SimpleClassifier> classifiers) {
        List<Mapping> mappings = new ArrayList<Mapping>();
        for (int i = 0; i < classifiers.size(); i++) {
            Mapping m = executeClassifier(classifiers.get(i), classifiers.get(i).threshold);
            mappings.add(m);
        }
        Mapping result = getIntersection(mappings);
        //System.out.println("***" + classifiers + "\n" + mappings + " => " + result + "***");
        return result;
    }

    /** Runs a classifier and get the mappings for it
     * 
     * @param c Classifier
     * @param threshold Threshold for similarities
     * @return Corresponding mapping
     */
    public Mapping executeClassifier(SimpleClassifier c, double threshold) {
        return execute(c.sourceProperty, c.targetProperty, c.measure, threshold);
    }

    /** Runs measure(sourceProperty, targetProperty) >= threshold
     * TODO: suport supervised approaches: using trimmedCaches.
     * @param sourceProperty Source property
     * @param targetProperty Target property
     * @param measure Similarity measure
     * @param threshold Similarity threshold
     * @return Correspoding Mapping
     */
    public Mapping execute(String sourceProperty, String targetProperty, String measure, double threshold) {
        String measureExpression = measure + "(x." + sourceProperty + ", y." + targetProperty + ")";
        Instruction inst = new Instruction(Command.RUN, measureExpression, threshold + "", -1, -1, -1);
        ExecutionEngine ee = new ExecutionEngine(source, target, "?x", "?y");
        return ee.executeRun(inst);
    }

    /** Computes the intersection of several mappings
     * 
     * @param mappings Maps classifiers to the resulting mappings
     * @return Intersection of the mappings
     */
    public static Mapping getIntersection(List<Mapping> mappings) {
        if (mappings.isEmpty()) {
            return new Mapping();
        }
        Mapping reference = mappings.get(0);
        Mapping result = new Mapping();
        for (String s : reference.map.keySet()) {
            for (String t : reference.map.get(s).keySet()) {
                boolean maps = true;
                for (int i = 1; i < mappings.size(); i++) {
                    Mapping m = mappings.get(i);
                    if (!m.contains(s, t)) {
                        maps = false;
                    }
                }
                if (maps) {
                    result.add(s, t, 1.0);
                }
            }
        }
        return result;
    }

    public List<SimpleClassifier> learnClassifer(List<SimpleClassifier> classifiers) {
        classifiers = normalizeClassifiers(classifiers);
        Mapping m = getMapping(classifiers);
        double f = computeQuality(m);
//        double f = _measure.getPseudoFMeasure(source.getAllUris(), target.getAllUris(), m, beta);
        // no need to update if the classifiers are already perfect
        if (f == 1.0) {
            return classifiers;
        }
        ComplexClassifier classifier = new ComplexClassifier(classifiers, f);
        ComplexClassifier bestClassifier = null;
        ComplexClassifier bestGlobalClassifier = classifier.clone();
        double bestF = 0;
        double globalBestF = f;
        int direction = 0;
        int iterations = 0;

        ComplexClassifier cc;
        while (iterations <= ITERATIONS_MAX) {
            iterations++;
            double fMeasure;
            int index = -1;
            bestF = 0;
            //evaluate neighbors of current classifier
            for (int i = 0; i < classifier.classifiers.size(); i++) {
                cc = computeNext(classifier, i);
                if (cc.fMeasure > bestF) {
                    bestF = cc.fMeasure;
                    index = i;
                    bestClassifier = cc;
                }
            }

            //every neighboring classifier is worse
            if (bestF < globalBestF) {
                return bestGlobalClassifier.classifiers;
            } //nothing better found. simply march in the space in direction 
            //"direction"
            else if (bestF == globalBestF) {
                System.out.println(">>>> Walking along direction " + direction);
                if (direction >= classifier.classifiers.size()) {
                    direction = 0;
                }
                bestClassifier = computeNext(classifier, direction);
                direction++;
                direction = direction % (classifier.classifiers.size());
            } //found a better classifier
            bestGlobalClassifier = bestClassifier.clone();
            globalBestF = bestF;
            //init for next iter
            classifier = bestClassifier;
            System.out.println(">> Iteration " + iterations + ": " + classifier.classifiers + " F-Measure = " + globalBestF + " Mapping = " + getMapping(classifiers));
        }
        return bestGlobalClassifier.classifiers;
    }

    public static void testIntersection() {
        Mapping m1 = new Mapping();
        m1.add("s1", "t1", 0.8);
        m1.add("s2", "t2", 0.8);
        m1.add("s3", "t3", 0.8);

        Mapping m2 = new Mapping();
        m2.add("s1", "t1", 0.8);
        m2.add("s3", "t3", 0.8);
//        m2.add("s2", "t2", 0.8);

        List<Mapping> list = new ArrayList<Mapping>();
        list.add(m1);
        list.add(m2);

        //System.out.println(getIntersection(list));
    }

    public void testa() {
        Cache source = new MemoryCache();
        Cache target = new MemoryCache();
        source.addTriple("s1", "name", "xigang");
        source.addTriple("s1", "surname", "hugong");
        source.addTriple("s2", "name", "xigang");
        source.addTriple("s2", "surname", "huo");
        source.addTriple("s3", "name", "xiang");
        source.addTriple("s3", "surname", "hu");

        target.addTriple("t1", "name", "xigang");
        target.addTriple("t1", "surname", "hugon");
        target.addTriple("t2", "name", "xigang");
        target.addTriple("t2", "surname", "huo");
        target.addTriple("t3", "name", "xiang");
        target.addTriple("t3", "surname", "hu");
//        target.addTriple("t4", "name", "zhou");
//        target.addTriple("t4", "surname", "han");


        BooleanSelfConfigurator bsc = new BooleanSelfConfigurator(source, target, 0.6, 1.0);
        List<SimpleClassifier> cp = bsc.getBestInitialClassifiers();
        System.out.println("Classifier:" + cp);
        cp = bsc.getInitialOverallClassifiers(cp);
        System.out.println("Normalized classifiers:" + cp);
//        cp = lsc.normalizeClassifiers(cp);
//        System.out.println("Normalized classifiers:" + cp);
//
        Mapping m = bsc.getMapping(cp);
        System.out.println("Initial FMeasure = " + computeQuality(m));
//        							_measure.getPseudoFMeasure(source.getAllUris(), target.getAllUris(), m, bsc.beta));
////        System.out.println("Mapping:" + m);
////        m = lsc.getBestOneToNMapping(m);
////        System.out.println("Cleaned mapping:" + m);
////        System.out.println("Final FMeasure = " + _measure.getPseudoFMeasure(source.getAllUris(),
////                target.getAllUris(), m, lsc.beta));
//
//        //lsc.computeNext(cp, 0);
//        //cp = lsc.buffer;
        cp = bsc.learnClassifer(cp);
        System.out.println("Best classifier:" + cp);
        m = bsc.getMapping(cp);
        System.out.println("Best F-Measure = " + computeQuality(m));
//        										_measure.getPseudoFMeasure(source.getAllUris(), target.getAllUris(), m, bsc.beta));


    }

    public static void main(String args[]) {
        (new BooleanSelfConfigurator(null, null, 0, 0)).testa();
    }
}
